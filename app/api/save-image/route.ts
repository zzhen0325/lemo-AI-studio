import { NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { z } from 'zod';

const BodySchema = z.object({
  imageBase64: z.string().min(1),
  ext: z.enum(['png', 'jpg', 'jpeg']).optional().default('png'),
  subdir: z.enum(['outputs', 'upload']).optional().default('outputs'),
  metadata: z.record(z.any()).optional(),
});

function extractBase64(data: string): { base64: string; mime?: string } {
  const match = data.match(/^data:(.*?);base64,(.*)$/);
  if (match) {
    return { base64: match[2], mime: match[1] };
  }
  return { base64: data };
}

export async function POST(request: Request) {
  try {
    const json = await request.json();
    const parsed = BodySchema.safeParse(json);
    if (!parsed.success) {
      return NextResponse.json({ error: 'Invalid payload', details: parsed.error.flatten() }, { status: 400 });
    }

    const { imageBase64, ext, subdir } = parsed.data;
    const { base64 } = extractBase64(imageBase64);

    const publicDir = path.join(process.cwd(), 'public');
    const targetDir = path.join(publicDir, subdir);
    await fs.mkdir(targetDir, { recursive: true });

    const stamp = Date.now();
    const rand = Math.random().toString(36).slice(2, 8);
    const filename = `img_${stamp}_${rand}.${ext}`;
    const filePath = path.join(targetDir, filename);

    await fs.writeFile(filePath, Buffer.from(base64, 'base64'));

    if (parsed.data.metadata) {
      const metadataPath = path.join(targetDir, `${filename.split('.')[0]}.json`);
      await fs.writeFile(metadataPath, JSON.stringify(parsed.data.metadata, null, 2));
    }

    const pathForClient = `/${subdir}/${filename}`;
    return NextResponse.json({ path: pathForClient });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to save image', details: String(error) }, { status: 500 });
  }
}


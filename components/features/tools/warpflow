#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

// === USER CONTROLLABLE PARAMETERS ===

// Cosine Gradient Options vec3(r, g, b) - https://iquilezles.org/articles/palettes/
const vec3 EXPOSURE = vec3(0.682,0.485,0.224);
const vec3 CONTRAST = vec3(-0.318,-0.296,0.028);
const vec3 FREQ = vec3(0.449,0.57,0.08);
const vec3 PHASE = vec3(2.967,1.05,2.323);



// Animation & Visual Controls
const int ZOOM = 40;                            // Iteration count / detail complexity (20-60 recommended)
const float ANIMATION_SPEED = 0.6;             // Overall animation speed multiplier (0.5 = slow, 2.0 = fast)
const float WARP_INTENSITY = 1.25;               // Distortion strength (0.5 = subtle, 2.0 = extreme)

// === END USER PARAMETERS ===

// Cosine gradient palette function
vec3 palette(float t) {
    return EXPOSURE + CONTRAST * cos(2.0 * PI * (FREQ * t + PHASE));
}

// Helper function for smooth parameter oscillation
float cosRange(float amt, float range, float minimum) {
    return (((1.0 + cos(radians(amt))) * 0.5) * range) + minimum;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    const float brightness = 1.0;
    float time = iTime * ANIMATION_SPEED;
    
    vec2 uv = fragCoord.xy / iResolution.xy;
    vec2 p = (2.0*fragCoord.xy - iResolution.xy) / max(iResolution.x, iResolution.y);

    // Animation Parameters
    float ct = cosRange(time*5.0, 3.0, 1.1);
    float xBoost = cosRange(time*0.2, 5.0, 5.0);
    float yBoost = cosRange(time*0.1, 10.0, 5.0);
    float fScale = cosRange(time*15.5, 1.25, 0.5);

    // Displacement Loop (iterative domain warping)
    for(int i = 1; i < ZOOM; i++) {
        float _i = float(i);
        vec2 newp = p;
        newp.x += 0.25/_i * sin(_i*p.y + time*cos(ct)*0.5/20.0 + 0.005*_i) * fScale * WARP_INTENSITY + xBoost;
        newp.y += 0.25/_i * sin(_i*p.x + time*ct*0.3/40.0 + 0.03*float(i+15)) * fScale * WARP_INTENSITY + yBoost;
        p = newp;
    }

    // Generate color using cosine gradient
    // Map warped coordinates to gradient parameter
    float gradientInput = (sin(p.x * 3.0) + sin(p.y * 3.0) + sin((p.x + p.y) * 2.0)) * 0.25 + 0.5;
    
    vec3 col = palette(gradientInput);
    col *= brightness;

    // Alpha channel based on color intensity
    float extrusion = (col.x + col.y + col.z) / 4.0;
    extrusion *= 1.5;
    
    fragColor = vec4(col, extrusion);
}